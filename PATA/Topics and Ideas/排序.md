### 思想解释

排序题主要是获取排序后的结果而不是过程，大部分代码可以使用 `sort()`函数进行直接处理，要熟练编写cmp排序规则（包括结构体形式的多变量规则）

有些题需要获取排名，只需在已经排序好的数组或容器中遍历全部的数据，如果和上一个数据相同，则排名相同，否则排名加1

### 类型练习

#### 1062

**题目：Talent and Virtue**

About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people's talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a "sage（圣人）"; being less excellent but with one's virtue outweighs talent can be called a "nobleman（君子）"; being good in neither is a "fool man（愚人）"; yet a fool man is better than a "small man（小人）" who prefers talent than virtue.

Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang's theory.

*Input Specification:*

Each input file contains one test case. Each case first gives 3 positive integers in a line: $N (≤105)$, the total number of people to be ranked; $L (≥60)$, the lower bound of the qualified grades -- that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and $H(<100)$, the higher line of qualification -- that is, those with both grades not below this line are considered as the "sages", and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are cosidered as the "noblemen", and are also ranked in non-increasing order according to their total grades, but they are listed after the "sages". Those with both grades below H, but with virtue not lower than talent are considered as the "fool men". They are ranked in the same way but after the "noblemen". The rest of people whose grades both pass the L line are ranked after the "fool men".

Then N lines follow, each gives the information of a person in the format:

 `ID_Number Virtue_Grade Talent_Grade`

where `ID_Number` is an 8-digit number, and both grades are integers in $[0, 100]$. All the numbers are separated by a space.

*Output Specification:*

The first line of output must give $M(≤N)$, the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID's.

*Sample Input:*

> 14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60

*Sample Output:*

> 12
10000013 90 99
10000012 80 100
10000003 85 80
10000011 85 80
10000004 80 85
10000007 90 78
10000006 83 76
10000005 82 77
10000002 90 60
10000014 66 60
10000008 75 79
10000001 64 90

**思路：**使用结构体对每个学生的信息进行存储，根据题意编写排序规则

- 存储学生信息的结构体除了基本信息外还应包含总成绩(total)与类别(rank)

- 编写排序规则，升序用小于号"<"，降序反之

- 使用动态容器vector创建一个结构体数组，处理时将及格的放入数组，最后输出size

- 在循环中创建一个临时结构体变量进行数据的处理，符合哪种条件就将rank置于相应的等级

- 需要注意读题， `not lower than`就代表 `>=`

**代码：**

```C++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Student
{
    int Id, virtue, talent, total;
    int rank; //表示类别，1~4
};

bool cmp(Student a, Student b)
{ //排序规则
    if (a.rank != b.rank)
    { //类别不同，按类别从小到大
        return a.rank < b.rank;
    }
    else if (a.total != b.total)
    {
        return a.total > b.total;
    }
    else if (a.virtue != b.virtue)
    {
        return a.virtue > b.virtue;
    }
    else
    { //全部相同，按学号
        return a.Id < b.Id;
    }
}

int main()
{
    int n, low, height;
    cin >> n >> low >> height;
    vector<Student> stu; //建立一个结构体的动态数组
    for (int i = 0; i < n; i++)
    {
        Student temp; //临时结构体变量
        cin >> temp.Id >> temp.virtue >> temp.talent;
        temp.total = temp.virtue + temp.talent; //对每一个数据都计算它的总成绩
        if (temp.virtue < low || temp.talent < low)
        {
            continue; //如果不符合条件直接处理下一个
        }
        else if (temp.virtue >= height && temp.talent >= height) //这里可以是等于
        {
            temp.rank = 1;
            stu.push_back(temp);
        }
        else if (temp.virtue >= height && temp.talent < height)
        {
            temp.rank = 2;
            stu.push_back(temp);
        }
        else if (temp.virtue < height && temp.talent < height && temp.virtue >= temp.talent) //不小于
        {
            temp.rank = 3;
            stu.push_back(temp);
        }
        else
        {
            temp.rank = 4;
            stu.push_back(temp);
        }
    }
    sort(stu.begin(), stu.end(), cmp); //根据规则排序
    cout << stu.size() << endl;        //输出符合条件的人数
    for (int i = 0; i < stu.size(); i++)
    { //按规则循环输出
        cout << stu[i].Id << " " << stu[i].virtue << " " << stu[i].talent << endl;
    }
    system("pause");
    return 0;
}
```

#### 1012

**题目：The Best Rank**

To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: `C` - C Programming Language, `M` - Mathematics (Calculus or Linear Algrbra), and `E` - English. At the mean time, we encourage students by emphasizing on their best ranks -- that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.

For example, The grades of `C`, `M`, `E` and `A` - Average of 4 students are given as the following:

```C
StudentID   C  M  E  A
 310101     98 85 88 90
 310102     70 95 88 84
 310103     82 87 94 88
 310104     91 91 91 91
```

Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.

*Input Specification:*

Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of `C`, `M` and `E`. Then there are M lines, each containing a student ID.

*Output Specification:*

For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.

The priorities of the ranking methods are ordered as `A` > `C` > `M` > `E`. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.

If a student is not on the grading list, simply output `N/A`.

*Sample Input:*

> 5 6
310101 98 85 88
310102 70 95 88
310103 82 87 94
310104 91 91 91
310105 85 90 90
310101
310102
310103
310104
310105
999999

*Sample Output:*

> 1 C
1 M
1 E
1 A
3 A
N/A

**思路：**编写排序规则对每一科进行排序将排名放到结构体相应位置，使用Map集合创建索引，进行查询

- 使用结构体对每个学生进行存储，成绩和排名用数组的方式创建

- 循环输入，平均分要四舍五入，使用 `answer+0.5`的方式实现

- 对每一科进行排序，编写循环式排序规则时，下标变量必须提前定义，处理并列排名的情况

- 将最后一轮排序（数据全部处理完）后的顺序，以ID为键，下标为值的方式放入Map集合方便查询(unordered_map时间更短)

- 对每一个被查询学生查找排名最小的一项，返回其值并获得课程下标，按格式输出

**代码：**

```C++
#include <iostream>
#include <algorithm>
#include <unordered_map>
using namespace std;

struct Student //学生结构体
{
    string Id;
    int grades[4], ranks[4];           //对应的成绩和排名
} stu[2000];                           //不会超过2000人
char course[5] = {'A', 'C', 'M', 'E'}; //对应的课程，方便输出（这里的构造顺序要和处理时的顺序必须一致，顺序用题目给出的优先级即可）
int now, r;                            //表示课程和排名的处理
bool cmp(Student a, Student b)
{
    return a.grades[now] > b.grades[now];
}

int main()
{
    int n, m;
    cin >> n >> m;
    unordered_map<string, int> Map; //用于存储ID对应的下标，方便查询
    for (int i = 0; i < n; i++)
    {
        cin >> stu[i].Id >> stu[i].grades[1] >> stu[i].grades[2] >> stu[i].grades[3];
        stu[i].grades[0] = (stu[i].grades[1] + stu[i].grades[2] + stu[i].grades[3]) / 3 + 0.5; //平均值四舍五入
    }

    for (now = 0; now < 4; now++) //按每科成绩进行排序
    {
        sort(stu, stu + n, cmp);
        for (int i = 0; i < n; i++)
        {
            if (stu[i].grades[now] != stu[i - 1].grades[now] || i == 0)
            {
                r = i + 1; //处理排名并列的情况
            }
            stu[i].ranks[now] = r;
        }
    }

    for (int i = 0; i < n; i++)
    {
        Map[stu[i].Id] = i; //数据处理完成后将ID和下标对应存储，方便查询
    }

    while (m--)
    {
        string query;
        cin >> query;
        if (!Map.count(query)) //没查询到元素
        {
            cout << "N/A\n";
        }
        else
        {
            int index = Map[query], minRank = 2001, cour; //查询到了，获取其下标
            for (int i = 0; i < 4; i++)
            {
                if (stu[index].ranks[i] < minRank)
                {
                    minRank = stu[index].ranks[i]; //寻找这个学生的最小排名
                    cour = i;                      //获取最小排名的课程下标
                }
            }
            cout << minRank << " " << course[cour] << endl;
        }
    }
    system("pause");
    return 0;
}
```

#### 1016

**题目：Phone Bills**

A long-distance telephone company charges its customers by the following rules:

> Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.

*Input Specification:*

Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.
The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from $00:00 - 01:00$, the toll from $01:00 - 02:00$, and so on for each hour in the day.
The next line contains a positive number $N (≤1000)$, followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (`MM:dd:HH:mm`), and the word `on-line` or `off-line`.
For each test case, all dates will be within a single month. Each `on-line` record is paired with the chronologically next record for the same customer provided it is an `off-line` record. Any `on-line` records that are not paired with an `off-line` record are ignored, as are `off-line` records not paired with an `on-line` record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.

*Output Specification:*

For each test case, you must print a phone bill for each customer.
Bills must be printed in alphabetical order of customers' names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (`dd:HH:mm`), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.

*Sample Input:*

> 10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10
10
CYLL 01:01:06:01 on-line
CYLL 01:28:16:05 off-line
CYJJ 01:01:07:00 off-line
CYLL 01:01:08:03 off-line
CYJJ 01:01:05:59 on-line
aaa 01:01:01:03 on-line
aaa 01:02:00:01 on-line
CYLL 01:28:15:41 on-line
aaa 01:05:02:24 on-line
aaa 01:04:23:59 off-line

*Sample Output:*

> CYJJ 01
01:05:59 01:07:00 61 $12.10
Total amount: $12.10
CYLL 01
01:06:01 01:08:03 122 $24.40
28:15:41 28:16:05 24 $3.85
Total amount: $28.25
aaa 01
02:00:01 04:23:59 4318 $638.80
Total amount: $638.80

**思路：**使用Map集合对名字自动排序，集合值为通话记录结构体组成的动态数组

- 使用结构体存储通话记录，定义一个time用来记录开年零点到记录的时间（分钟为单位）方便后续比较和处理

- 使用Map集合存储姓名对应的结构体数组，Map自动排序，处理时遍历取出即可

- 对取出的数组中对所有的通话记录进行排序，判断每两条记录的状态进行话费的计算

**代码：**

```C++
#include <iostream>
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
using namespace std;

struct Record //结构体记录每条通话记录的信息，名字是公共的所以无需放入
{
    string status;
    int month, day, hour, minute, time; //time表示的是开年零点到现在的时间（分钟为单位）
};

bool cmp(Record a, Record b) //定义一个时间的排序规则
{
    return a.time < b.time;
}

int main()
{
    double rate[24]; //输入收费标准，时间也是从0开始，无需进行下标的增减
    for (int i = 0; i < 24; i++)
    {
        cin >> rate[i];
    }
    int n;
    cin >> n;
    getchar();                          //后边输入字符串，截获换行符
    map<string, vector<Record>> custom; //用名字作为键值，直接对其进行排序
    for (int i = 0; i < n; i++)
    {
        Record temp;
        string temp_name; //作为键放入Map，临时变量即可
        cin >> temp_name;
        //cin>> temp.month >> temp.day >> temp.hour >> temp.minute;
        //这种输出对有":"间隔的数据无法处理，可以加一个char c截获,或使用下面scanf的方式输入
        scanf("%d:%d:%d:%d", &temp.month, &temp.day, &temp.hour, &temp.minute);
        cin >> temp.status;
        temp.time = temp.day * 1440 + temp.hour * 60 + temp.minute; //统一转换成分钟方便运算
        custom[temp_name].push_back(temp);                          //以姓名为键，记录数组为值放入集合
    }
    for (auto it : custom)
    {
        auto temp_V = it.second;                 //将每个人的通话记录数组拿出来，对每个数组进行处理
        sort(temp_V.begin(), temp_V.end(), cmp); //对所有的通话记录进行排序
        double total_bill = 0;
        for (int i = 0; i < temp_V.size();) //分组判断，不直接递增
        {
            if (i + 1 < temp_V.size() && temp_V[i].status > temp_V[i + 1].status) //on按字典序高于off，一组符合规则的数据
            {
                if (!total_bill) //使用非的方式只输出一次姓名，后续total有值便为0
                {
                    cout << it.first;
                    printf(" %02d\n", temp_V[i].month);
                }
                double per_bill = 0;
                int time1 = temp_V[i].time, time2 = temp_V[i + 1].time;
                for (int j = time1; j < time2; j++) //模拟时间
                {
                    per_bill += rate[j % 1440 / 60]; //每分钟的单价相加
                }
                printf("%02d:%02d:%02d ", temp_V[i].day, temp_V[i].hour, temp_V[i].minute);
                printf("%02d:%02d:%02d ", temp_V[i + 1].day, temp_V[i + 1].hour, temp_V[i + 1].minute);
                printf("%d $%.2f\n", temp_V[i + 1].time - temp_V[i].time, per_bill / 100);
                total_bill += per_bill;
                i += 2; //一组成功下一组
            }
            else
            {
                i++; //一组不成功，以结束时间作为下一组的开始时间
            }
        }
        if (total_bill) //这个是在人物之外，还需判断一次，防止有人存在的账单都不符合条件但还是输出了total_bill
        {
            printf("Total amount: $%.2f\n", total_bill / 100); //账单以时间为单位
        }
    }
    system("pause");
    return 0;
}
```

#### 1025

**题目：PAT Ranking**

Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.

*Input Specification:*

Each input file contains one test case. For each case, the first line contains a positive number $N (≤100)$, the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer $K (≤300)$, the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.

*Output Specification:*

For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:

 `registration_number final_rank location_number local_rank`

The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.

*Sample Input:*

> 2
5
1234567890001 95
1234567890005 100
1234567890003 95
1234567890002 77
1234567890004 85
4
1234567890013 65
1234567890011 25
1234567890014 100
1234567890012 85

*Sample Output:*

> 9
1234567890005 1 1 1
1234567890014 1 2 1
1234567890001 3 1 2
1234567890003 3 1 2
1234567890004 5 1 4
1234567890012 5 2 2
1234567890002 7 1 5
1234567890013 8 2 3
1234567890011 9 2 4

**思路：**结构体+动态数组存储，分情况处理排名，考场内排名的处理用临时数组每输入完一个考场处理一次的形式

**代码：**

```C++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Student
{
    string num;
    int score, ranks[2], room; //ranks[0]代表总排名，1代表考场排名
};
bool cmp(Student a, Student b) //排序规则
{
    return a.score == b.score ? a.num < b.num : a.score > b.score;
}
int r; //处理并列排名

int main()
{
    int n, m;
    cin >> n;
    vector<Student> stu; //所有成员的结构体动态数组
    for (int i = 0; i < n; i++)
    {
        cin >> m;
        getchar(); //捕捉换行符
        Student temp_stu[m];
        for (int j = 0; j < m; j++)
        {
            cin >> temp_stu[j].num >> temp_stu[j].score;
            temp_stu[j].room = i + 1; //考场号就等于组数+1
        }
        sort(temp_stu, temp_stu + m, cmp); //对一个考场的所有成员进行排序
        for (int k = 0; k < m; k++)
        {
            if (k == 0 || temp_stu[k].score != temp_stu[k - 1].score)
            {
                r = k + 1;
            }
            temp_stu[k].ranks[1] = r;   //赋值考场排名
            stu.push_back(temp_stu[k]); //放入总数组
        }
    }
    sort(stu.begin(), stu.end(), cmp); //公共排名处理
    for (int i = 0; i < stu.size(); i++)
    {
        if (i == 0 || stu[i].score != stu[i - 1].score)
        {
            r = i + 1;
        }
        stu[i].ranks[0] = r;
    }
    cout << stu.size() << endl;
    for (int i = 0; i < stu.size(); i++)
    {
        cout << stu[i].num << " " << stu[i].ranks[0] << " " << stu[i].room << " " << stu[i].ranks[1] << endl;
    }
    system("pause");
    return 0;
}
```

#### 1028

**题目：List Sorting**

Excel can sort records according to any column. Now you are supposed to imitate this function.

*Input Specification:*

Each input file contains one test case. For each case, the first line contains two integers $N (≤10^5)$ and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student's record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).

*Output Specification:*

For each test case, output the sorting result in N lines. That is, if $C = 1$ then the records must be sorted in increasing order according to ID's; if $C = 2$ then the records must be sorted in non-decreasing order according to names; and if $C = 3$ then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID's in increasing order.

*Sample Input 1:*

> 3 1
000007 James 85
000010 Amy 90
000001 Zoe 60

*Sample Output 1:*

> 000001 Zoe 60
000007 James 85
000010 Amy 90

**思路：**设置变量C在排序规则之外，根据C的值返回相应的规则；注意non-decreasing表示非降序（≠升序）比较运算符要用 `<=`

**代码：**

```C++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Student
{
    string Id, name;
    int score;
};
int c;
bool cmp(Student a, Student b)
{
    if (c == 1)
    {
        return a.Id < b.Id;
    }
    else if (c == 2)
    {
        return a.name == b.name ? a.Id < b.Id : a.name <= b.name;
    }
    else if (c == 3)
    {
        return a.score == b.score ? a.Id < b.Id : a.score <= b.score;
    }
    return 0;
}

int main()
{
    int n;
    vector<Student> stu;
    scanf("%d%d", &n, &c);
    for (int i = 0; i < n; i++)
    {
        Student temp;
        cin >> temp.Id >> temp.name >> temp.score;
        stu.push_back(temp);
    }
    sort(stu.begin(), stu.end(), cmp);
    for (int i = 0; i < stu.size(); i++)
    {
        printf("%s %s %d\n", stu[i].Id.c_str(), stu[i].name.c_str(), stu[i].score);
    }
    system("pause");
    return 0;
}
```

#### 1055

**题目：The World's Richest**

Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world's wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages.

*Input Specification:*

Each input file contains one test case. For each case, the first line contains 2 positive integers: $N (≤10^5)$ - the total number of people, and $K (≤10^3)$ - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in $(0, 200]$), and the net worth (integer in $[−106,106]$) of a person. Finally there are K lines of queries, each contains three positive integers: $M (≤100)$ - the maximum number of outputs, and [`Amin`, `Amax`] which are the range of ages. All the numbers in a line are separated by a space.

*Output Specification:*

For each query, first print in a line `Case #X:` where `X` is the query number starting from 1. Then output the M richest people with their ages in the range [`Amin`, `Amax`]. Each person's information occupies a line, in the format

 `Name   Age   Net_Worth`

The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output `None`.

*Sample Input:*

> 12 4
Zoe_Bill 35 2333
Bob_Volk 24 5888
Anny_Cin 95 999999
Williams 30 -22
Cindy 76 76000
Alice 18 88888
Joe_Mike 32 3222
Michael 5 300000
Rosemary 40 5888
Dobby 24 5888
Billy 24 5888
Nobody 5 0
4 15 45
4 30 35
4 5 95
1 45 50

*Sample Output:*

> Case #1:
Alice 18 88888
Billy 24 5888
Bob_Volk 24 5888
Dobby 24 5888
Case #2:
Joe_Mike 32 3222
Zoe_Bill 35 2333
Williams 30 -22
Case #3:
Anny_Cin 95 999999
Michael 5 300000
Alice 18 88888
Cindy 76 76000
Case #4:
None

**思路：**使用多个结构体动态数组，挑选数据后只排序一次，减少复杂度

- 结构体的字符串使用字符数组，，配合scanf()减少复杂度

- 输入数据后按规则进行排序，如果年龄相同只保存100人，减少遍历长度

**代码：**

```C++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;

struct Person
{
    char name[10]; //使用字符数组，配合scanf()减少复杂度
    int age, money;
};

bool cmp(Person a, Person b)
{
    if (a.money != b.money)
    {
        return a.money >= b.money;
    }
    else if (a.age != b.age)
    {
        return a.age <= b.age;
    }
    else
    {
        return strcmp(a.name, b.name) <= 0; //字符数组的排序
    }
}

int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
    vector<Person> temp_in(n); //输入数组
    for (int i = 0; i < n; i++)
    {
        scanf("%s %d %d", &temp_in[i].name, &temp_in[i].age, &temp_in[i].money);
    }
    sort(temp_in.begin(), temp_in.end(), cmp); //排序
    vector<int> book(201, 0);
    vector<Person> people;
    for (int i = 0; i < n; i++)
    {
        if (book[temp_in[i].age] < 100) //每个年龄都不超过100人
        {
            people.push_back(temp_in[i]); //缩小数据放到新数组
            book[temp_in[i].age]++;
        }
    }
    int m, Amin, Amax; //将循环输入的变量放到循环外减少语句量
    for (int i = 0; i < k; i++)
    {
        scanf("%d %d %d", &m, &Amin, &Amax);
        vector<Person> temp_out;
        for (int j = 0; j < people.size(); j++)
        {
            if (people[j].age >= Amin && people[j].age <= Amax)
            {
                temp_out.push_back(people[j]); //将符合条件的放入输出数组
            }
        }
        printf("Case #%d:\n", i + 1);
        bool flag = false;
        for (int l = 0; l < m && l < temp_out.size(); l++) //有不足m的情况，加一个大小的判断条件
        {
            printf("%s %d %d\n", temp_out[l].name, temp_out[l].age, temp_out[l].money);
            flag = true;
        }
        if (!flag)
        {
            printf("None\n");
        }
    }
    system("pause");
    return 0;
}
```

#### 1075

**题目：PAT Judge**

The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.

*Input Specification:*

Each input file contains one test case. For each case, the first line contains 3 positive integers, $N (≤10^4)$, the total number of users, $K (≤5)$, the total number of problems, and $M (≤10^5)$, the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to N, and the problem id's are from 1 to K. The next line contains K positive integers `p[i]` (`i`=1, ..., K), where `p[i]` corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format:

 `user_id   problem_id   partial_score_obtained`

where `partial_score_obtained` is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, `p[problem_id]`]. All the numbers in a line are separated by a space.

*Output Specification:*

For each test case, you are supposed to output the ranklist in the following format:

 `rank   user_id   total_score   s[1] ... s[K]`

where `rank` is calculated according to the `total_score`, and all the users with the same `total_score` obtain the same `rank`; and `s[i]` is the partial score obtained for the `i`-th problem. If a user has never submitted a solution for a problem, then "-" must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.

The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.

*Sample Input:*

> 7 4 20
20 25 25 30
00002 2 12
00007 4 17
00005 1 19
00007 2 25
00005 1 20
00002 2 2
00005 1 15
00001 1 18
00004 3 25
00002 2 25
00005 3 22
00006 4 -1
00001 2 18
00002 1 20
00004 1 15
00002 4 18
00001 3 4
00001 4 2
00005 2 -1
00004 2 0

*Sample Output:*

> 1 00002 63 20 25 - 18
2 00005 42 20 0 22 -
2 00007 42 - 25 - 17
2 00001 42 18 18 4 2
5 00004 40 15 0 25 -

**思路：**创建一个N人的结构体数组，输入时直接以ID作为下标进行输入

- 结构体进行存储，需要自行添加的变量有： `isShow`只要有一条通过编译，置为true表示可以输出； `passnum`表示满分题目数量

- 输入记录时会有一个人重复提交的情况，每次比对相同ID是不现实的，直接创建一个数据规模为$N+1$的结构体数组，以ID作为下标进行记录提交处理

- 输入的成绩不止未通过和有成绩两种状态，还有未提交的情况，将成绩的初始值置为-2表示未提交

- 记录输入完成根据有效成绩，计算total_score和passnum

- 进行排序后为每名同学赋值rank，然后判断isShow的值循环输出

**代码：**

```C++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int n, k, m; //总人数，问题数和提交记录的数量
struct Record
{
    int rank, Id, passnum = 0;              //passnum表示完美通过的数量
    int score[6] = {0, -2, -2, -2, -2, -2}; //-2==没有提交过；-1==没通过编译
    bool isShow = false;                    //若没有一条能够通过编译不显示
};

bool cmp(Record a, Record b)
{
    if (a.score[0] != b.score[0])
    {
        return a.score[0] >= b.score[0];
    }
    else if (a.passnum != b.passnum)
    {
        return a.passnum >= b.passnum;
    }
    else
    {
        return a.Id < b.Id;
    }
}

int main()
{
    scanf("%d %d %d", &n, &k, &m);
    vector<Record> v(n + 1);     //输入记录的时候遍历寻找是哪个人进行提交是不现实的，直接用ID作为下标
    int full_score[k];           //保存每道题目的成绩上限
    for (int i = 1; i <= k; i++) //题号从1开始
    {
        scanf("%d", &full_score[i]); //输入每一题的满分
    }
    int Id, pro_num, score_obt;
    for (int i = 0; i < m; i++)
    {
        scanf("%d %d %d", &Id, &pro_num, &score_obt);
        v[Id].Id = Id;
        v[Id].score[pro_num] = max(v[Id].score[pro_num], score_obt); //多次提交保留最大值
        if (score_obt != -1)                                         //只要有成绩就置为可以输出
        {
            v[Id].isShow = true;
        }
    } //输入处理完成

    for (int i = 1; i <= n; i++) //学生的序号一直到n
    {
        for (int j = 1; j <= k; j++) //题目的序号一直到k
        {
            if (v[i].score[j] != -2 && v[i].score[j] != -1)
            {
                v[i].score[0] += v[i].score[j]; //相加有效成绩
            }
            if (v[i].score[j] == full_score[j])
            {
                v[i].passnum++; //记录满分数量
            }
        }
    }
    sort(v.begin() + 1, v.end(), cmp); //0恒为空值
    for (int i = 1; i <= n; i++)       //赋予排名
    {
        v[i].rank = i;
        if (i != 1 && v[i].score[0] == v[i - 1].score[0])
        {
            v[i].rank = v[i - 1].rank;
        }
    } //处理完成

    for (int i = 1; i <= n; i++)
    {
        if (v[i].isShow) //判断有无输出条件按格式输出
        {
            printf("%d %05d %d", v[i].rank, v[i].Id, v[i].score[0]);
            for (int j = 1; j <= k; j++)
            {
                if (v[i].score[j] != -1 && v[i].score[j] != -2)
                    printf(" %d", v[i].score[j]);
                else if (v[i].score[j] == -2)
                    printf(" -");
                else
                    printf(" 0");
            }
            printf("\n");
        }
    }
    system("pause");
    return 0;
}
```

#### 1083

**题目：List Grades**

Given a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.

*Input Specification:*

Each input file contains one test case. Each case is given in the following format:

```C
N
name[1] ID[1] grade[1]
name[2] ID[2] grade[2]
... ...
name[N] ID[N] grade[N]
grade1 grade2
```

where `name[i]` and `ID[i]` are strings of no more than 10 characters with no space, `grade[i]` is an integer in $[0, 100]$, `grade1` and `grade2` are the boundaries of the grade's interval. It is guaranteed that all the grades are **distinct**.

*Output Specification:*

For each test case you should output the student records of which the grades are in the given interval [`grade1`, `grade2`] and are in non-increasing order. Each student record occupies a line with the student's name and ID, separated by one space. If there is no student's grade in that interval, output `NONE` instead.

*Sample Input 1:*

> 4
Tom CS000001 59
Joe Math990112 89
Mike CS991301 100
Mary EE990830 95
60 100

*Sample Output 1:*

> Mike CS991301
Mary EE990830
Joe Math990112

*Sample Input 2:*

> 2
Jean AA980920 60
Ann CS01 80
90 95

*Sample Output 2:*

> NONE

**思路：**输入完成后根据区间判断，记录符合范围的个数，不符合将值改为-1，排序输出

**代码：**

```C++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Student
{
    string name, Id;
    int score;
};

bool cmp(Student a, Student b)
{
    return a.score > b.score;
}

int main()
{
    int n;
    cin >> n;
    vector<Student> stu;
    Student temp;
    for (int i = 0; i < n; i++)
    {
        cin >> temp.name >> temp.Id >> temp.score;
        stu.push_back(temp);
    }
    int low, height;
    int count = 0;
    cin >> low >> height;
    for (int i = 0; i < stu.size(); i++)
    {
        if (stu[i].score < low || stu[i].score > height)
        {
            stu[i].score = -1;
        }
        else
        {
            count++;
        }
    }
    if (count)
    {
        sort(stu.begin(), stu.end(), cmp);
        for (int i = 0; i < count; i++)
        {
            cout << stu[i].name << " " << stu[i].Id << endl;
        }
    }
    else
    {
        cout << "NONE\n";
    }
    system("pause");
    return 0;
}
```

#### 1080

**题目：Graduate Admission**

It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.

Each applicant will have to provide two grades: the national entrance exam grade $G_E$, and the interview grade $G_I$. The final grade of an applicant is $(G_E+G_I)/2$. The admission rules are:

- The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.

- If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade $G_E$. If still tied, their ranks must be the same.

- Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.

- If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, **even if its quota will be exceeded**.

*Input Specification:*

Each input file contains one test case.Each case starts with a line containing three positive integers: $N (≤40,000)$, the total number of applicants; $M (≤100)$, the total number of graduate schools; and $K(≤5)$, the number of choices an applicant may have.

In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively.

Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant's $G_E$ and $G_I$, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1.

*Output Specification:*

For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.

*Sample Input:*

> 11 6 3
2 1 2 2 2 3
100 100 0 1 2
60 60 2 3 5
100 90 0 3 4
90 100 1 2 0
90 90 5 1 3
80 90 1 0 2
80 80 0 1 2
80 80 0 1 2
80 70 1 3 2
70 80 1 2 3
100 100 0 2 4

*Sample Output:*

> 0 10
3
5 6 7
2 8
1 4

**思路：**同时建立学生学校两个结构体分别进行处理

- 学校结构体创建一个last变量，方便比对招满后最后一人的排名是否有与之并列的存在

- 学生结构体创建ID变量和rank保存原始编号和排名

- 按成绩排序分配排名后，对每个学生进行处理，遍历每个学生的志愿，判断是否达到入校条件

- 对每个学校的招入名单排序输出

**代码：**

```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct School
{
    int quota, last;   //last为录取的最后一个学生用来判断同排名
    vector<int> admit; //被录取的学生放到该数组
} school[100];

struct Applicant
{
    int Id, rnk, Ge, Gi, G; //学生ID要单独保存
    int choice[5];
} alct[40000];

int N, M, K;
bool cmp(Applicant a, Applicant b)
{
    if (a.G != b.G)
    {
        return a.G > b.G;
    }
    return a.Ge > b.Ge;
}

int main()
{
    cin >> N >> M >> K;
    for (int i = 0; i < M; i++)
    {
        cin >> school[i].quota; //输入每个学校的招生人数
    }
    for (int i = 0; i < N; i++)
    {
        cin >> alct[i].Ge >> alct[i].Gi;
        for (int j = 0; j < K; j++)
        {
            cin >> alct[i].choice[j];
        }
        alct[i].G = alct[i].Ge + alct[i].Gi; //相加即可
        alct[i].Id = i;                      //将编号保存，排序后仍使用原始编号
    }
    sort(alct, alct + N, cmp); //将学生按成绩排名
    for (int i = 0; i < N; i++)
    {
        if (i == 0 || alct[i].G != alct[i - 1].G || alct[i].Ge != alct[i - 1].Ge)
        { //分配名次
            alct[i].rnk = i + 1;
        }
        else
        {
            alct[i].rnk = alct[i - 1].rnk;
        }
    }
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < K; j++)
        {
            int k = alct[i].choice[j]; //遍历所有志愿
            if (school[k].admit.size() < school[k].quota || alct[i].rnk == alct[school[k].last].rnk)
            {                                          //人数没招满或与招到最后一人的排名相等
                school[k].admit.push_back(alct[i].Id); //ID放入数组
                school[k].last = i;                    //覆盖最后值
                break;
            }
        }
    }
    for (int i = 0; i < M; i++)
    {
        sort(school[i].admit.begin(), school[i].admit.end()); //对每个学校照到的学生按序号排序
        for (int j = 0; j < school[i].admit.size(); j++)
        {
            if (j)
            { //不是第一个就输出空格
                cout << " ";
            }
            cout << school[i].admit[j];
        }
        cout << endl;
    }

    system("pause");
    return 0;
}
```

#### 1095

**题目：Cars on Campus**

Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.

*Input Specification:*

Each input file contains one test case. Each case starts with two positive integers $N(≤10^4)$, the number of records, and $K (≤8×10^4)$ the number of queries. Then N lines follow, each gives a record in the format:

 `plate_number   hh:mm:ss   status`

where `plate_number` is a string of 7 English capital letters or 1-digit numbers; `hh:mm:ss` represents the time point in a day by hour:minute:second, with the earliest time being `00:00:00` and the latest `23:59:59`; and `status` is either `in` or `out`.

Note that all times will be within a single day. Each `in` record is paired with the chronologically next record for the same car provided it is an `out` record. Any `in` records that are not paired with an `out` record are ignored, as are `out` records not paired with an `in` record. It is guaranteed that at least one car is well paired in the input, and no car is both `in` and `out` at the same moment. Times are recorded using a 24-hour clock.

Then K lines of queries follow, each gives a time point in the format `hh:mm:ss`. Note: the queries are given in **ascending** order of the times.

*Output Specification:*

For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.

*Sample Input:*

> 16 7
JH007BD 18:00:01 in
ZD00001 11:30:08 out
DB8888A 13:00:00 out
ZA3Q625 23:59:50 out
ZA133CH 10:23:00 in
ZD00001 04:09:59 in
JH007BD 05:09:59 in
ZA3Q625 11:42:01 out
JH007BD 05:10:33 in
ZA3Q625 06:30:50 in
JH007BD 12:23:42 out
ZA3Q625 23:55:00 in
JH007BD 12:24:23 out
ZA133CH 17:11:22 out
JH007BD 18:07:01 out
DB8888A 06:30:50 in
05:10:00
06:30:50
11:00:00
12:23:42
14:00:00
18:00:00
23:59:00

*Sample Output:*

> 1
4
5
2
1
0
1
JH007BD ZD00001 07:20:09

**思路：**使用MAP集合存储数据，车牌号为键，结构体数组为值

- 使用结构体对出入记录进行存储，同时计算记录是在一天中的第几秒

- 遍历集合，将每个车牌对应的记录数组进行排序，进行出入配对，将当前时间点放入出入数组中，并累积一个车牌号停车的时长

- 遍历一天中的86400秒，将每秒的停车数量记录下来，公式：时间点前的所有进减去所有出

- 比较所有时长取出停车时间最长的，并列也放入数组，然后对车牌号排序

**代码：**

```C++
#include <iostream>
#include <unordered_map>
#include <algorithm>
#include <vector>
using namespace std;

struct Record
{
    string p_num, statu;
    int hour, mintue, second, time; //存储当前时间点在一天中是第多少秒
};
unordered_map<string, vector<Record>> msvr; //记录集合
unordered_map<string, int> msi;             //停靠时间集合
int N, K;
int in_school[86400] = {0};  //在这一秒有多少车辆进入
int out_school[86400] = {0}; //在这一秒有多少车辆出去

bool cmp(Record a, Record b)
{
    return a.time < b.time; //时间从早到晚排序
}

int main()
{
    cin >> N >> K;
    for (int i = 0; i < N; i++)
    {
        Record temp;
        cin >> temp.p_num;
        scanf("%d:%d:%d", &temp.hour, &temp.mintue, &temp.second);
        cin >> temp.statu;
        temp.time = temp.hour * 3600 + temp.mintue * 60 + temp.second;
        msvr[temp.p_num].push_back(temp); //将每次输入的记录放到车牌号对应的数组中
    }
    for (auto it : msvr) //遍历集合
    {
        auto v = it.second; //将每个车牌号对应的数组取出
        sort(v.begin(), v.end(), cmp);
        for (int i = 0; i < v.size();)
        {
            if (v[i].statu == "in") //进行配对处理
            {
                if (i + 1 < v.size() && v[i + 1].statu == "out")
                {
                    in_school[v[i].time]++; //将in的状态放到对应的时间点
                    out_school[v[i + 1].time]++;
                    msi[it.first] += v[i + 1].time - v[i].time; //统计停车时长
                    i += 2;                                     //下一组
                }
                else
                {
                    i++;
                }
            }
            else
            {
                i++;
            }
        }
    }

    int car_cnt[86400];
    int t = 0;
    for (int i = 0; i < 86400; i++)
    {
        t += in_school[i];
        t -= out_school[i];
        car_cnt[i] = t; //每个时间的车辆==之前所有的进-所有的出
    }

    int t_h, t_m, t_s;
    for (int i = 0; i < K; i++)
    {
        scanf("%d:%d:%d", &t_h, &t_m, &t_s);
        printf("%d\n", car_cnt[t_h * 3600 + t_m * 60 + t_s]);
    }
    int max_time = 0;
    vector<string> maxcars; //存储并列的最久车辆，保存车牌号
    for (auto it : msi)
    {
        if (it.second > max_time)
        {
            max_time = it.second;
            maxcars = {it.first}; //现在是唯一的答案，直接赋值（不使用放入，因为每次赋值都要清空前面所有的）
        }
        else if (it.second == max_time)
        {
            maxcars.push_back(it.first); //现在是并列的答案，放入
        }
    }
    sort(maxcars.begin(), maxcars.end()); //根据字符排序
    for (string each : maxcars)
    {
        cout << each << " ";
    }
    printf("%02d:%02d:%02d", max_time / 3600, max_time / 60 % 60, max_time % 60);
    system("pause");
    return 0;
}
```

## 总结

1. 如果需要对排序进行查询，一定要数据全部处理完成后再放入MAP集合或其他容器中，不然会导致下标混乱，如T1012

2. 排序型算法要处理的数据难免过大，可以采用以下方式缩小复杂度：

- 将局部变量定义在循环外，尽量缩小循环内的执行语句量

- 输入输出函数使用scanf()和printf()，字符串可以使用字符数组，排序使用strcmp()函数

- 局部多次排序可以使用单次排序，尤其对大型数据的小型查询，如T1028

1. 循环中进行比较的动态数组，不要直接放入，存在每次比较过后要清空之前数据的可能，直接赋值，如T095